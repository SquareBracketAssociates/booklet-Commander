## For framework designersThe design of Commander favors strong extensibility while keeping its use simple. The extensibility is brought in by using a simple decorator pattern.The idea is to propose a simple API to users while giving the possibility to modularly extend the framework.In this chapter, we explain the key aspects of Commander so that developers of other frameworks can use it as the root of theirsolution. We show the integration of Commander and Spec as a concrete use case.### Decorating commandsBy default a command does not know about Spec specific behavior. It can be used in other contexts such as scripting libraries as this was the case with Gofer \(Gofer was a scripting API to script monticello\).The design of Commander supports the following scenario: the idea is that the core behavior of PharoLauncher should be able to be exposed as Clap command-line using the fact that PharoLauncher define commands.The Spec project extends Commander so that we use commands with specific aspects related to Spec.It uses the fact that Commander allows us to decorate commands with decoration that are polymorphic to commands as shown in Figure *@decorator@*.![Commands and command decorators.](figures/FirstDecorator.pdf width=90&label=decorator)Let us describe Figure *@decorator@*:- The common abstract root class `CmAbstractCommand` defines way to manage the context and execute a command.- The class `CmBlockCommand` is a generic command whose behavior is specified using a block. - The class `CmCommand` is the main root class of commands. Users will usually subclass it. For example, `EgAddContactCommand` subclasses it as shown in Figure *@specdecorator@*. Without Spec integration, the class `CmCommand` does not have any behavior related to Spec. The only interesting extension point is the `decorateWith:` method that is an extension hook as we show later. - The class `CmCommandDecorator` is the root of command decorators. It merely delegates to a decorated command. It supports dynamic name and descriptions \(to be able to get more specialized and dynamically updated commands\). At runtime, decorators will be created to wrap a command and as such provide more information.- The class `CmUICommand` is a decorator of command dedicated for UI related state and actions. Note that it is not linked per se to Spec. It offers some general functionalities related to UI, as we saw in previous chapters:  - State: icon, shortcutKey  - Behavior: defining icon, and shorcutKeyNow we are ready to study the Spec integration.### Modular Spec command decorationFigure *@specdecorator@* shows how Commander is extended to support Spec specific behavior and this in a modular way.First the class `SpCommand` is a Spec specific decorator. For example, it contains logic how to turn a command into a button presenter.Second, the package containing the Spec related code extends the class `CmCommand` with the `asSpecCommand` method.  The method `asSpecCommand` decorates a command to define extra behavior responsible for the addition of ui related functionality and state. ![Spec decorations and use.](figures/DecoratorWithSpec2.pdf width=90&label=specdecorator)The implementation is the following one```CmCommand >> asSpecCommand
	^ self decorateWith: SpCommand```It means that the base command will be decorated by an instance of the class `SpCommand`.Remember that the method `asSpecCommand` is directly or indirectly used by the developer to build commands that he will register to the command root of its presenter. The following method shows a typicall command instantiation.```EgContactBookPresenter >> buildAddingGroupWith: presenter
	^ (CmCommandGroup named: 'Adding') asSpecGroup
			description: 'Commands related to contact addition.';
			register: (EgAddContactCommand forSpec context: presenter);
			beDisplayedAsGroup;
			yourself```The method `forSpec` is a handy creation class method.```CmCommand class >> forSpec
	^ self new asSpecCommand```### Spec Commander user perspective What is interesting to note is that as an end-user the developer defining the command has just to define the method `asSpecCommand` without having to worry about the details of the implementation. Here is the command definition for the command of adding a contact in our contact book application.```EgAddContactCommand >> asSpecCommand
	^ super asSpecCommand
		shortcutKey: $n meta;
		iconName: #changeAdd;
		yourself```The command `EgAddContactCommand` is a subclass of `CmCommand` and not `SpCommand`.If the execute method does not perform or use UI specific behavior this makes sense and it makespossible to use the command without such constraints.Now if your commands are UI specific you can also define them as subclass of `SpCommand`.`SpCommand` is a decorator so inheriting from it would be a mistake because the state and behavior of commandwould not be available since there would be no decorated command.### Decorating group of commandsCommander uses the same logic for group of commands as shown by Figure *@group@*.Let us describe the hierarchy.- The class `CmAbstractCommandGroup` is an abstract root defining elementary operation of group.- The class `CmCommandGroup` is the central class from an end-user point of view.- The class `CmCommandGroupDecorator` is just a decorator. ![Group and group decorators.](figures/DecoratorGroup.pdf width=50&label=group)On top of this the class `CmUICommandGroup` extends the basic decorator with ui related behavior as shown in Figure *@groupspec@*.### Spec decoration The Spec extension then is based on the definition of a specific decorator `SpCommandGroup` and the method `asSpecGroup` defined as follows: ```CmCommandGroup >> asSpecGroup
	^ self decorateWith: SpCommandGroup```The class `SpCommandGroup` defines methods that are producing Spec object often using the ```SpCommandGroup >> asMenuPresenter
	^ SpMenuPresenterBuilder new
		visit: self;
		menuPresenter```![Spec's group and group decorators.](figures/DecoratorGroupSpec.pdf width=45&label=groupspec)### Example of Visitor: toolbarBuilderCommander defines a simple visitor. This visitor is used in many places. Here we present the `SpToolBarPresenterBuilder`responsible for turning groups into a toolbar. ```SpCommandGroup >> asToolbarPresenter
	^ SpToolBarPresenterBuilder new
		visit: self;
		toolbarPresenter``````SpvisitCommand: aCmCommandEntry
	aCmCommandEntry positionStrategy
		addButton: (SpToolBarButton new
						label: aCmCommandEntry name;
						help: aCmCommandEntry description;
						icon: aCmCommandEntry icon;
						action: [ aCmCommandEntry execute ];
						yourself)
		toToolbar: self toolbarPresenter```![Full design: Core, UI support and Spec integration.](figures/DesignAdvanced.pdf width=110&label=advanced)### Conclusion To conclude this chapter Figure *@advanced@* gives a full overview of the design and layers supported by Commander.We show that Commander proposes a simple way for user to express commands while at the same time commands can be modularly decorated to add extra behavior. Commander20 is a central piece of Pharo infrastructure and all the other commands solutions will be ported to it. 