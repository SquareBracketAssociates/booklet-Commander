!!Commander: a Powerful and Simple Command Framework

Commander was a library originally developed by Denis Kudriashov. 
Commander 2.0 is the second iteration of such a library. 
It has designed and developed by Julien Delplanque and StÃ©phane Ducasse.
Note that Commander 2.0 is not compatible with Commander but this is really easy to migrate from Commander to Commander 2.0.
We describe Commander 2.0 in the context of Spec 2.0, the user interface building framework.
From then on, when we mention Commander we refer to Commander 2.0.
In addition we show how to extend Commander to other needs.



!!! Commands

Commander models application actions as first class objects following the Command design pattern.
With Commander, you can express commands and use them to generate menus, toolbar but also to script an application from the command line.

Every action is implemented as a separate command class (subclass of ==CmCommand==) with an ==execute== method and all state required for execution.
The superclass defines the context in which the command should be executed. 
Then the class ==CmCommand== introduces name and description.

+A simple command and its hierarchy.>figures/BasicCommand.pdf|width=35|label=first+

We will show later that for UI framework, we need more information such as an icon and shortcut description.
In addition we will present how commands can be decorated with extra functionality in an extensible way.

Note that nothing prevents you to define commands by creating instances and filling them up with the same information.
If you do so, you cannot use classes to dispatch and should put in place other mechanisms. 
In this chapter we only discuss how to define class representing commands and use them. 

!!! Defining commands
A command is a simple object instance of a subclass of the class ==CmCommand==.
It has a description, a name (this name can be either static or dynamic as we will shown later on). 
In addition, it has a context from which it extracts information to execute itself. 
In its basic form there is not much more than that.

Let us have a look at examples. 
We will define some commands for the ContactBook application and illustrate how they can be turned into 
menu and menubar.


Note that we will present how Commander supports Spec menu and menubar creations.
However such functionalities are not in the core of Commander.
We show them because first this is important to illustrate how to build user interfaces elements with Commander but also 
because such functionalities show that Commander can be extended in a way that end-users do not have to feel 
they are using special extensions.
We will come back to such point in the last chapter of this book to show to potential extenders of Commander that they can 
get inspiration from the Spec extensions.





!!! Adding some convenience methods

For convenience reasons, we define a common superclass named ==EgContactBookCommand== to all the commands  of the contact book application.

[[[
CmCommand subclass: #EgContactBookCommand
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EgContactBook'
]]]


We define a simple helper method to make the code more readable
[[[
EgContactBookCommand >> contactBookPresenter
	^ self context
]]]

For the same reason, we define another helper to access the contact book and the selected item.
[[[
EgContactBookCommand >> contactBook
	^ self contactBookPresenter contactBook
]]]

[[[
EgContactBookCommand >> selectedContact
	^ self contactBookPresenter selectedContact
]]]

Using such helper methods we defined the method ==hasSelectContract== as follows:

[[[
EgContactBookCommand >> hasSelectedContact
	^ self contactBookPresenter isContactSelected
]]]

!!!! Adding the add contact command

We define a subclass to define the add a contact command. 
[[[
EgContactBookCommand subclass: #EgAddContactCommand
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EgContactBook'
]]]

[[[
CmAddContactCommand >> initialize
	super initialize.
	self
		basicName: 'New contact'; 
		basicDescription: 'Creates a new contact and add it to the contact book.'
]]]

[[[
CmAddContactCommand >> execute
	
	| contact |
	contact := self contactBookPresenter newContact.
	self hasSelectedContact
		ifTrue: [ self contactBook addContact: contact after: self selectedContact ]
		ifFalse: [ self contactBook addContact: contact ].
		
	self contactBookPresenter updateView
]]]

We should define the method ==updateView== to refresh the contents of the table.

[[[
EgContactBookPresenter >> updateView
	table items: contactBook contacts
]]]

Now in the inspect pane we can simply execute the command as follows:

[[[
(EgAddContactCommand new context: self) execute
]]]

Excuting the command should ask you to give a name and a phone number
and will get added to the list.

We can also execute the following snippet.

[[[
| presenter cmd |
presenter := EgContactBookPresenter on: EgContactBook coworkers.
cmd := EgAddContactCommand new context: presenter.
cmd execute
]]]

!!! Adding the remove contact command

We define now another command to remove a command. 
This example is interesting because it does not involve any UI interaction.
It shows that a command is not necessarily linked to UI interaction.

[[[
EgContactBookCommand subclass: #EgRemoveContactCommand
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EgContactBook'
]]]

[[[
EgRemoveContactCommand >> initialize
	super initialize.
	self
		name: 'Remove'; 
		description: 'Removes the selected contact from the contact book.'
]]]

This command definition illustrates how we can control when a command should or not be executed. The method ==canBeRun== allows one to specify such condition.

[[[
EgRemoveContactCommand >> canBeExecuted
	^ self context isContactSelected
]]]

The method ==execute== is straightforward.
[[[
EgRemoveContactCommand >> execute
	self contactBook removeContact: self selectedContact.
	self contactBookPresenter updateView
]]]

The following test validates the correct execution of the command.

[[[
EgContactCommandTest >> testRemoveContact

	self assert: presenter contactBook size equals: 3.
	presenter table selectIndex: 1.
	(EgRemoveContactCommand new context: presenter) execute.
	self assert: presenter contactBook size equals: 2
]]]


!!! Turning commands into menu items
Now that we have our commands we would like to reuse them and turn them into menus. 
In Spec, commands that are transformed into menu items are structured into a tree of command instances. 
The class method ==buildCommandsGroupWith:forRoot:== of ==SpPresenter== is a hook to let  presenters define the root of the command instance tree.

A command is transformed into a command for Spec using the message ==forSpec==.
We will show later that we can add UI specific information to a command such as an icon and a shortcut.

The method ==buildCommandsGroupWith:forRoot:== registers commands to which the presenter instance is passed as context. 
Note that here we just add plain commands, but we can also create groups. 
This is also in this method that we will specify toolbar.

[[[
EgContactBookPresenter class >> 
	buildCommandsGroupWith: presenter 
	forRoot: rootCommandGroup
	
	rootCommandGroup 
		register: (EgAddContactCommand forSpec context: presenter);
		register: (EgRemoveContactCommand forSpec context: presenter)
]]]

We have now have to attach the root of the command tree to the table. 
This is what what we do with the new line in the ==initializePresenters== method. 
Notice that we have the full control and as we will show we could select a subpart of the tree (using the message ==/==) and defining as root for given component.


[[[
EgContactBookPresenter >> initializePresenters
	table := self newTable.
	table 
		addColumn: (SpStringTableColumn title: 'Name' evaluated: #name);
		addColumn: (SpStringTableColumn title: 'Phone' evaluated: #phone).
	table contextMenu: [ self rootCommandsGroup beRoot asMenuPresenter ].
	table items: contactBook contacts.
]]]

Reopening the interface ==(EgContactBookPresenter on: EgContactBook coworkers) openWithSpec== you should see the menu items as shown in Figure *@withmenu*.
As we will show later we could even replace a menu item by another one, changing its name, or icon in place.

+With two menu items with groups.>figures/withMenus.png|width=60|label=withmenu+

!!! Introducing groups

Commands can be managed in groups and such groups can be turned into corresponding menu item sections.
The key hook method is the class method named ==buildCommandsGroupWith: presenterInstance forRoot:==.


Here we give an example of such grouping. 
Note that the message ==asSpecGroup== sent to a group.
We create two method creating each a simple group one for adding and one for removing contracts.

[[[
EgContactBookPresenter class >> buildAddingGroupWith: presenter
	^ (CmCommandGroup named: 'Adding') asSpecGroup
		description: 'Commands related to contact addition.';
		register: (EgAddContactCommand forSpec context: presenter);
		beDisplayedAsGroup;
		yourself
]]]

[[[
EgContactBookPresenter class >> buildRemovingGroupWith: presenter
	^ (CmCommandGroup named: 'Removing') asSpecGroup
		description: 'Commands related to contact removal.';
		register: (EgRemoveContactCommand forSpec context: presenter);
		beDisplayedAsGroup;
		yourself
]]]

We group the previously defined groups together under contextual menu for example. 

[[[
EgContactBookPresenter class >> buildContextualMenuGroupWith: presenter
	^ (CmCommandGroup named: 'Context Menu') asSpecGroup
		register: (self buildAddingGroupWith: presenter);
		register: (self buildRemovingGroupWith: presenter);
		yourself
]]]

Finally we revisit the hook ==buildCommandsGroupWith:forRoot:== to register the last group to the root command group.

[[[
EgContactBookPresenter class >> 
	buildCommandsGroupWith: presenter 
	forRoot: rootCommandGroup
	
	rootCommandGroup
		register: (self buildContextualMenuGroupWith: presenter)
]]]

Reopening the interface ==(EgContactBookPresenter on: EgContactBook coworkers) openWithSpec== you should see the menu items inside a =='Context Menu'== as shown in Figure *@withmenuContext*.

+With a context menu.>figures/withmenuContext.png|width=60|label=withmenuContext+

To show you that we can also select a part of the command tree we select the =='Context Menu'== group and we declare it as the root of the table menu.
In such case you will not see the =='Context Menu'== anymore. 

[[[
EgContactBookPresenter >> initializePresenters

	table := self newTable.
	table 
		addColumn: (SpStringTableColumn title: 'Name' evaluated: #name);
		addColumn: (SpStringTableColumn title: 'Phone' evaluated: #phone).
	
	table contextMenu: [ (self rootCommandsGroup / 'Context Menu') beRoot asMenuPresenter ].
	table items: contactBook contacts
]]]	

!!! Extending menus

Building menu is nice, but sometimes we need to add a menu into an existing one. 
Commander supports this via a dedicated pragma, called ==<extensionCommands>== that identifies extensions. 

as we show it now. 


Imagine that we have a new functionality that we want to add to the contact book and that this behavior is packaged in another package, here, ==EgContactBook-Extensions==.
First we will define a new command and second we will show how we can extend the existing menu to add a new menu item. 

[[[
EgContactBookCommand subclass: #EgChangePhoneCommand
	instanceVariableNames: 'newPhone'
	classVariableNames: ''
	package: 'EgContactBook-Extensions'
]]]

[[[
EgChangePhoneCommand >> newPhone: anObject
	newPhone := anObject
]]]

[[[
EgChangePhoneCommand >> newPhone
	^ newPhone 
]]]

[[[
EgChangePhoneCommand >> initialize
	super initialize.
	self
		name: 'Change phone';
		description: 'Change the phone number of the contact.'
]]]

[[[
EgChangePhoneCommand >> execute
	self selectedContact phone: self contactBookPresenter newPhone.
	self contactBookPresenter updateView
]]]

We add ==ContactBookPresenter== with the method ==newPhone== the presenter to support the definition of the new phone number. 
The point here is not that this is method is or not packaged with the new command.

[[[
EgContactBookPresenter >> newPhone
	| phone |
	phone := self 
		request: 'New phone for the contact'
		initialAnswer: self selectedContact phone 
		title: 'Set new phone for contact'.
	(phone matchesRegex: '\d\d\d\s\d\d\d')
		ifFalse: [ 
			SpInvalidUserInput signal: 'The phone number is not well formated. 
Should match "\d\d\d\s\d\d\d"' ].
	^ phone
]]]

The last missing piece is the declaration of the extension.
This one is done using the pragma ==\<extensionCommands\>== on the class side of the presenter class as follows:

Here we see that using slash (== / ==), we can select the group in which we want to add the item.

[[[
EgContactBookPresenter class >> 
	changePhoneCommandWith: presenter 
	forRootGroup: aRootCommandsGroup
	
	<extensionCommands>
	
	(aRootCommandsGroup / 'Context Menu')
		register: (EgChangePhoneCommand forSpec context: presenter)
]]]


+With menu extension.>figures/withmenuExtension.png|width=60|label=withmenuExtension+


!!! Managing icons and shortcuts

By default a command does not know about Spec specific behavior, this is because a command does not have to be linked to UI.
Now obviously you want to have icons and shortcut bindings when you are designing an interactive application.

Commander supports the addition of icons and shortcut key to commands.
Let us see how it works from a user perspective. 
The framework offers two methods to set icon and shortcut key ==iconName:== and ==shortcutKey:== and we should specialize the method ==aSpecCommand== as follows: 

[[[
EgRemoveContactCommand >> asSpecCommand
	^ super asSpecCommand
		iconName: #removeIcon;
		shortcutKey: $x meta;
		yourself
]]]


[[[
EgRemoveContactCommand >> asSpecCommand
	^ super asSpecCommand
		shortcutKey: $n meta;
		iconName: #changeAdd;
		yourself
]]]

Note that the commands are created using the message ==forSpec== and this is this message that takes care about the calling of ==asSpecCommand==.

!!! Enabling shortcuts

To the time of this chapter writing, Commander management of shortcuts has not been pushed to Spec to avoid dependency to Commander. 
It is then the responsibility of your presenter to manage shortcuts as shown in the following method.
We ask the command group to install the shortcut handler in the window.

[[[
EgContactBookPresenter >> initializeWindow: aWindowPresenter
	
	super initializeWindow: aWindowPresenter.
	self rootCommandsGroup installShortcutsIn: aWindowPresenter
]]]

!!! In place customisation

Commander supports also the reuse and in place customisation of commands.
It means that the instance representing a command can be modified on the spot: for example its name or description can be adapted to the exact 
use context.
Here is an example that shows that we adapt twice the same command.

Let us define a really simple and generic command which will simply inspect the object. 

[[[
EgContactBookCommand subclass: #EgInspectCommand
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EgContactBook-Extensions'
]]]

[[[
EgInspectCommand >> initialize
	super initialize.
	self
		name: 'Inspect';
		description: 'Inspect the context of this command.'
]]]

[[[
EgInspectCommand >> execute
	self context inspect
]]]

Using a block the context is computed at the moment the command is executed and the name and description can be adapted for its specific usage as shown in Figure *@inPlaceCustomisation*.

[[[
EgContactBookPresenter class >>	
	extraCommandsWith: presenter 
	forRootGroup: aRootCommandsGroup
	
	<extensionCommands>
	
	aRootCommandsGroup / 'Context Menu'
		register:
			((CmCommandGroup named: 'Extra') asSpecGroup
				description: 'Extra commands to help during development.';
				register:
					((EgInspectCommand forSpec context: [ presenter selectedContact ])
						name: 'Inspect contact';
						description: 'Open an inspector on the selected contact.';
						iconName: #smallFind;
						yourself);
				register:
					((EgInspectCommand forSpec context: [ presenter contactBook ])
						name: 'Inspect contact book';
						description: 'Open an inspector on the contact book.';
						yourself);
				yourself)
]]]

+With menu extension.>figures/inPlaceCustomisation.png|width=95|label=inPlaceCustomisation+

!!! Managing a menu bar

Commander supports also menu bar creation.
The logic is the same than for contextual menus: we define a group and register it under a given and we specify to the presenter to use this group 
as a menubar.

Imagine that we have a new command to print the contact.

[[[
EgContactBookCommand subclass: #EgPrintContactCommand
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EgContactBook'
]]]

[[[
EgPrintContactCommand >> initialize
	super initialize.
	self
		name: 'Print';
		description: 'Print the contact book in Transcript.'	
]]]

[[[
EgPrintContactCommand >> execute

	Transcript open.
	self contactBook contacts do: [ :contact | self traceCr: contact name , ' - ' , contact name ]
]]]


We create a simple group that we call 'MenuBar' (but it could be called anything).

[[[
EgContactBookPresenter class >> buildMenuBarGroupWith: presenter
	^ (CmCommandGroup named: 'MenuBar') asSpecGroup
		register: (EgPrintContactCommand forSpec context: presenter);
		yourself
]]]

We modify the root to get the menu bar group in addition the previous ones. 
[[[
EgContactBookPresenter class >> 
	buildCommandsGroupWith: presenter 
	forRoot: rootCommandGroup
	
	rootCommandGroup
		register: (self buildMenuBarGroupWith: presenter);
		register: (self buildContextualMenuGroupWith: presenter)
]]]

And we hook it into the widget as the last line of the ==initializePresenters== method. 
Notice the use of the message ==asMenuBarPresenter== and the addition of a new instance variable called ==menuBar==.

[[[
EgContactBookPresenter >> initializePresenters
	table := self newTable.
	table 
		addColumn: (SpStringTableColumn title: 'Name' evaluated: #name);
		addColumn: (SpStringTableColumn title: 'Phone' evaluated: #phone).
	table contextMenu: [ (self rootCommandsGroup / 'Context Menu') beRoot asMenuPresenter ].
	table items: contactBook contents.
	menuBar := (self rootCommandsGroup / 'MenuBar') asMenuBarPresenter.
]]]	

Finally to get the menu bar you should declare it in the layout.

[[[
EgContactBookPresenter class >> defaultSpec

	^ SpBoxLayout newVertical
			add: #menuBar
			withConstraints: [ :constraints | constraints height: self toolbarHeight ];
			add: #table; 
			yourself
]]]

+With menubar.>figures/withmenubar.png|width=60|label=inPlaceCustomisation+


!!! Conclusion

In this chapter we saw how you can define a simple command, execute it in a given context. 
We show how you can turn command into menu item in Spec20 by sending the message ==forSpec==. 
You learned how we can reuse and customize commands. 
We presented groups of commands as a way to structure menus and menubars. 

In the next chapter we will provide more details about certains UI aspects. 


!! Tips and Tricks

In this chapter we will detail some APIs that can be useful and some tips and tricks.


!!! Icon Provider
The Commander' Spec extension (Commander for short in the rest of the chapter) has no preconcieved idea about where to look for icons.
By default it used internally the fonctionality provider by Spec presenters.

Now Commander lets you also specify your own source of icon provider using the message 
==iconProvider:==.

This way you can manage your own icon set without having to register in the system. 


!!! PharoLauncher icon tricks

You may want to do a specific treatment on your icon form before displaying them. 
You may want to add or modify the icons form. 
Here is a typical example made in the PharoLauncher to get a greyed icon. 
Pay attention that ==iconNamed:== is a protected method in the sense that only subclasses of Command may redefine it. 

[[[
PhLLaunchImageCommand2 >> iconNamed: aName

	^ (super iconNamed: aName) asGrayScaleWithAlpha
]]]

!!! Extra Spec behavior

SD: Julien I need help

The integration of Commander into Spec20 allows one to access features that are only available for menu items,

- ==beDisabledWhenCantBeRun==.  Julien help please. How we know that it cannot be run? How do I specify the condition? Can I specify the condition?  Pay attention  that this is static feature in the sense that it is evaluated at the command creation. Is it true?
- ==beHiddenWhenCantBeRun== Julien help please. How we know that it cannot be run? How do I specify the condition? Can I specify the condition?  Pay attention  that this is static feature.

- ==beDisplayedOnRightSide== and ==beDisplayedOnLeftSide==. Julien help please the right side of what?

!!! Contexts can be dynamic

If you want your command to work on a context that will change at execution, pass a block as argument of the ==context:== message.

SD: put an example

!!! Dynamic name and description

Commander allows you to customize the name and description of a command. 
The idea is to let you provide description or name that take advantage of the context in which they are used.

SD: Julien when dynamicDescription is invoked?

!!! Toolbar

Commands can also be turned into a toolbar using the message ==asToolbarPresenter== sent to a group of commands.

SD: Ask christophe for an example

!!! Registration and navigation

Commands are often grouped together to act as menu groups. 
In the previous chapter we show that a group is structured as a composite tree of groups and commands. 
Adding elements to such composite is done via  the messages ==register: aGroupOrCommand==. 


We show that the message ==/== navigates the tree and access the corresponding subtree.

SD: Show add an example here

The Spec extension supports also the notion of order and substitution as follows: 
- ==registerFirst: aGroupOrCommand==
- ==registerLast: aGroupOrCommand==
- ==register: aGroupOrCommand after: another== and ==register:aGroupOrCommand before: another==
- ==register: aGroupOrCommand insteadOf: another==
-unregister:

